---
title:  "배열에서 중복하지 않고 무작위로 숫자 뽑기"
date:   2015-05-07 09:28:26
categories: algorithm
---


로또 번호 추출 처럼 N개의 배열에서 중복하지 않고 M개의 번호를 무작위로 추출하기.
 
로또처럼 쉽게 N을 45, M을 6이라고 하자.
1부터 45에서 무작위로 6개의 숫자를 중복되지 않게 뽑아야 한다. 최대한 효율적으로...  
(1) N개의 숫자에서  
(2) M개를  
(3) 무작위로  
(4) 중복되지 않게  
(5) 효율적으로 뽑아야 한다.  
 
{% highlight c %}
#define N 45
#define M 6
int arr[N];
for(int i=0; i<N; i++){
    arr[i] = i+1;
}
{% endhighlight %}
 
### 방법1.
 
말 그대로 무작위로 뽑는다.
중복을 고려하기위해, 이미 뽑은 숫자를 다른 배열에 저장하고
매번 뽑을 때 마다 이미 뽑은 숫자인지 찾아보고, 만약 이미 뽑은 숫자라면 다시 위의 동작을 반복한다.

{% highlight c %}
int arr2[N];
for( i=0; i<M; i++){
    do{
        r = rand()%N;
    } while r in arr2:
    arr2.push(r);
}
{% endhighlight %}

가장 직관적이지만 경우에 따라 매우 비효율적이 될 수 있다.
특히 N이 매우 크고, M도 N에 가까운 큰 값일 경우, while문을 빠져나오기가 힘들 수 있다.
 
 
### 방법2.

배열을 shuffling 한다. 그리고 앞에서 부터 6개의 숫자를 출력한다.
이경우 shuffling만 제대로 된다면 6개의 숫자를 뽑는 것은 매우 빠르고 효율적이다.
{% highlight python %}
arr.shuffle()
for i in xrange(M):
    print arr[i]
{% endhighlight %}
문제는 처음 배열을 shuffling 하는 것이다.
만약 배열의 크기 N이 45가 아니라 100000000 처럼 매우 큰 경우
shuffling하는데 매우 큰 비용이 든다.
배열을 효율적으로 shuffling 하는 방법에 대해서도 다음에 포스팅해보겠다.


### 방법3.
 
딱 M번만에 원하는 결과를 얻을 수 있다.
위의 방법1과 비슷하다.
주머니속에서 숫자를 하나 뽑고, 다시 또 뽑을 땐, 이미 뽑은 숫자는 없기 때문에 중복되지 않는 다는 점을 이용한다.
"배열에서 숫자를 뽑는다"라는 동작을 코드로 효율적으로 표현하는 것이 문제의 핵심이다.
링크드 리스트와는 달리, 배열은 메모리 공간이 서로 인접해 있어, 중간의 값을 제거할 경우 그 뒤의 모든 값을 한칸씩 옮겨야 하는 비효율적인 작업이 필요하다.
하지만 한칸씩 옮겨야 하는 경우는 배열의 정렬된 상태를 유지시키기 위한 것인데, 무작위로 숫자를 뽑는 경우는 이런 정렬된 상태 유지 조건이 필요 없다. 따라서 효율적으로 빈 공간을 메꾸기만 하면 된다.
 
배열에서 숫자 하나를 뽑고, 그 공간에 배열의 가장 뒷 부분 숫자를 옮겨넣으면 된다.
 
{% highlight c %}
int n = N;
for(int i=0; i<M; i++){
    int r = arr[rand()%n];
    arr[r] = arr[--n];
}
{% endhighlight %}
단점은 미리 값이 들어간 배열이 필요하다는 점이다.
딱 M번만에 M개의 숫자를 중복되지 않게 무작위로 뽑았다.